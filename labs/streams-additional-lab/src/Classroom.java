import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

public class Classroom {

    private static final Teacher teacher = new Teacher("Bob", 45, "London");
    private static final List<Student> students = createStudents();

    public static void main(String[] args) {
        // Task 1
        findStudentsByAge(30);

        // Task 2
        getHighAchievers(60);

        // Task 3
        getHalfTeacherAgeStudents();

        // Task 4
        calculateAverageGrade();

        // Task 5
        getStudentNames();

        // Task 6
        System.out.println(getGradesMap());

        // Task 7
        System.out.println(sortStudentsByAge());

        // Task 8
        System.out.println(sortStudentsByGrade());

        // Task 9
        System.out.println(findTopPerformers(3));

        // Task 10
        System.out.println(findLowestPerformers(3));

        // Task 11
        System.out.println(studentsByCity());

        // Task 12
        System.out.println(getInPersonTutoringStudents());

        // Task 13
        getUniqueStudentsByCity();

        // Task 14
        System.out.println(groupStudentsByAgeRange());

        // Task 15
        searchStudents("Adam", 25, 44);
    }

    /* This function generates a list of students where each student have a specific name based on the loop counter: Student #1, Student #2 ...
        Each student has a specific age that should be an integer between 18 and 50
        The grade is calculated using the same method as calculating the age, except the limits are 0 - 100.
        The cities are generated by getting the available zones from the ZoneId class.
        Each zone id is a string that contains a continent name and a country/city name separated by a slash "/" (i.e. Europe/Berlin)
        Therefore, we extract the city by creating a substring that goes from the "/" to the end of the string (sometimes we get a country instead of a city)
        An additional test is to skip the zone ids that have a "GMT" instead of a country/city name (i.e. Etc/GMT+8). In this case, we continue until we get a proper value.
        */
    private static List<Student> createStudents() {
        ArrayList<Student> list = new ArrayList<>();
        Iterator<String> iterator = ZoneId.getAvailableZoneIds().iterator();

        for (int i = 1; i <= 20; i++) {
            String city = iterator.next();
            while (city.contains("GMT")) {
                city = iterator.next();
            }
            list.add(new Student("Student #" + i, (int) (Math.random() * 50 + 18), Math.random() * 100.0 + 1.0, city.substring(city.indexOf("/") + 1)));
        }
        return list;
    }

    private static void findStudentsByAge(int age) {
        students.stream().filter(student -> student.age() < age).forEach(System.out::println);
    }

    private static void getHighAchievers(double minGrade) {
        students.stream().filter(student -> student.grade() >= minGrade).forEach(System.out::println);
    }

    private static void getHalfTeacherAgeStudents() {
        students.stream().filter(student -> student.age() <= teacher.age() / 2).forEach(System.out::println);
    }

    private static void calculateAverageGrade() {
        System.out.println(students.stream().mapToDouble(Student::grade).average().orElse(-1));
    }

    private static void getStudentNames() {
        System.out.println(students.stream().map(Student::name).collect(Collectors.joining(", ")));
    }

    private static Map<Character, List<Student>> getGradesMap() {
        return students.stream().collect(Collectors.groupingBy(student -> {
            if (student.grade() >= 90) return 'A';
            else if (student.grade() >= 80) return 'B';
            else if (student.grade() >= 70) return 'C';
            else return 'D';
        }));
    }

    private static List<Student> sortStudentsByAge() {
        return students.stream().sorted(Comparator.comparingInt(Student::age)).toList();
    }

    private static List<Student> sortStudentsByGrade() {
        return students.stream().sorted(Comparator.comparingDouble(Student::grade).reversed()).toList();
    }

    private static List<Student> findTopPerformers(int count) {
        return sortStudentsByGrade().stream().limit(count).toList();
    }

    private static List<Student> findLowestPerformers(int count) {
        return sortStudentsByGrade().reversed().stream().limit(count).toList();
    }

    private static Map<String, List<Student>> studentsByCity() {
        return students.stream().collect(Collectors.groupingBy(Student::city));
    }

    private static List<Student> getInPersonTutoringStudents() {
        return students.stream().filter(student -> student.city().equals(teacher.city())).toList();
    }

    private static void getUniqueStudentsByCity() {
        System.out.println(students.stream().collect(Collectors.groupingBy(Student::city, Collectors.minBy(Comparator.comparing(Student::name)))));
    }

    private static Map<String, List<Student>> groupStudentsByAgeRange() {
        return students.stream().collect(Collectors.groupingBy(student -> {
            if (student.age() <= 29 && student.age() >= 20) return "20-29";
            else if (student.age() <= 39 && student.age() >= 30) return "30-39";
            else if (student.age() <= 49 && student.age() >= 40) return "40-49";
            else if (student.age() <= 59 && student.age() >= 50) return "50-59";
            else return "-1";
        }));
    }

    private static void searchStudents(String name, int age, double grade) {
        students.stream().filter(student -> student.name().equals(name) && student.age() == age && student.grade() == grade).forEach(System.out::println);
    }

    private record Student(String name, int age, double grade, String city) {
        public Student(String name, int age, double grade, String city) {
            this.name = name;
            this.age = age;
            this.grade = Double.valueOf(grade).intValue();
            this.city = city;
        }

        @Override
        public String toString() {
            return "Student{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    ", grade=" + grade +
                    ", city='" + city + '\'' +
                    '}';
        }
    }

    private record Teacher(String name, int age, String city) {
    }
}